===========================SOFTWARE-ENGINEERING-COURSE===========================

Engineering software is the Engineering that studys the software development,
your lifecicle, concepts and techiniques.


------------------------------------CONCEPTS-------------------------------------

COT Systems:

Are system that was created genericlly to sell and is adapted to the client ne-
eds.

---------------------------------------------------------------------------------

CR: Changes Request: Is where the client solicite changes in the project. The CR
need be appraised before to implement.

---------------------------------------------------------------------------------

BaseLine: Are the stable lines that are reliable to implement in the software.

---------------------------------------------------------------------------------

Codeline: Is the line that represent the version each item in the software.

---------------------------------------------------------------------------------

Checkout: Is when a developer copy the realible code of the project to work with
it. If a developer is doing checkout in a version of code, another developer can
not doing this together or a merge is done.

---------------------------------------------------------------------------------

Checking: Is when the developer already worked on the reliable code and delive-
ry again with a new reliable version to the system of changes manager.

---------------------------------------------------------------------------------

Version: Is the current version of the software development. Your changes should 
be documented within the follow settings: Version, Changer, Data, Author and Re-
ason of changes.

---------------------------------------------------------------------------------

Release: Is the current version of the software release to the client.

---------------------------------------------------------------------------------

Software Design:

The software desing is responsable for the code level design, watch wich module 
does and the scope and objectives of each class and function.

---------------------------------------------------------------------------------

Fast Methods:

Fast methods are methods more flexibles and focused in more development instead of 
documentation. Fast methods are borned due the software crysis where the develo-
pment of software are hard and expansive. Examples of fast methods: XP, SCRUM, 
TDD(Test driven development)

Principles of fast methods:

Relationshio with the client,
Incremental delivery,
Focus on peoples istead of porcess,
Maintain simple

---------------------------------------------------------------------------------

SCRUM: 

The SCRUM are composed of various sprints (cycles) where evaluate, select, review 
and develop the project.


....
---------------------------------------------------------------------------------

Functional requiremnts:

Functional requirements: Are the functions that the system will to execute. Exam-
ples: Do login, calc the buy amount, send a e-mail and etc.

---------------------------------------------------------------------------------

No functional requirements:

No functional requirements: Are how the functions will executed, are the techs u-
sed, are the system performance, a time to execute a task.

Main observations on writing requirements:

- All requirements should be implemented;
- Diferent requirements can't diverge;
- The requirement should be real and can be tested;

Always review your requirements.

---------------------------------------------------------------------------------

Legad System:

System that not receives more manutention.


--------------------------PROCESS TO DEVELOP SOFTWARES---------------------------

-----------------------------Particular Softwares--------------------------------

1)Meet your client and do the techinique interview with forms to get your require-
ments.

2)Define the requirements, functionals and no functionals.

3)Draw the Class Diagram and the Case Use Diagram.

4)Build your software on Figma.

5)Code your software always thinking in your reuse.

6)Run test in each requirement.

7)Deploy your software by according the client accord.

-------------------------------Public Softwares----------------------------------

1)Meet your client and do the techinique interviw with forms to get your require-
ments.

2)Define the requirements, functionals and no functionals.

3)Draw the Class Diagram and the Case Use Diagram.

4)Build your software on Figma.

5)Code your software always thinking in your reuse.

6)Run test in each requirement.

7)Deploy your software.

8)Document your project on GitHub.

------------------------------SOFTWARE LIFE CYCLE--------------------------------

Elicitation: Stage where a meeting with the client is realized. Goes to meet with 
a questionary and be specifi to question the client about he want. The client in 
most cases don't know what want. Observe the manual work of the client and think 
how the system can change this. Consult diferent stakeholders.


---------------------------MODELS OF SOFTWARE PROCESS----------------------------

The models of software development process represents the life cicle of each mo-
del process.

CASCADE:
The process folow a logic sequencial where a task is finished and another is 
started automatically.

Requirements definition > Project of software and system > Implementation and 
unity test > Integration and system test > Operation and handling

---------------------------------------------------------------------------------

INCREMENTAL:
In this process, the kernel of the software is build, and new features are incre-
menteds to software and validated.

Sketch > Development > < Especification > < Validation (are done various versions
of the software).

---------------------------------------------------------------------------------

ORIENTED TO REUSE:
This model described the reuse of components of software already developed. At a-
dopting this method, you need be careful, because the same functionalities of the
software already developed perhaps can be to not attend the client requirements.
At choicing this model, run more tests.

Requirement especification > Components analisys > Requirement changes > Project 
of system with reuse > Development and integration > System validation

Obs: Unrely of the model development choiced, always to follow the steps:
Especification > Development > Validation > Evolution

-----------------------MAIN TOOLS OF SOFTWARE ENGINEERING--------------------------

Entity Relationship Diagram

Data Flow Diagram

Case Use Diagram**

Case Use Specification

Class Diagram**

Sequence Diagram

Activities Diagram**

The Diagram Class is the best diagram to define the system structure.


-------------------MAIN ARCHITETURAL MODELS/DESING PATTERNS-----------------------

Design patern is the techinic of to format default software projects and reuse 
this. This architeture is responsable for the software structure.

Layered pattern:

Is strucutured on stacked layers where the down layers server the up layer and bo-
th comunicates. In the most bottom layers, has the back-end and in the most top 
layer has the user interface. The nearster layers access your neightbor and the 
mostup layer don't acess the most bottom layer.

----------------------------------------------------------------------------------

Client-server pattern:

Has a server of a side and another side has a client, where the client request da-
ta for the server and the server return a response to the client.

----------------------------------------------------------------------------------

MVC pattern:

Model View Controller: Is an architeture where the banck-end is controlled by the 
Model, the browser is responsable to renver the info (View) and the HTML and Java-
script act like the Controller.

----------------------------------------------------------------------------------

Serverless architeture:

Is the architetuere where the software rely of third services to manage your back-
end. It is split in two categories: Back as services and Fun��es as services. A 
good example of this architetures is the Amazon Web Services.

----------------------------------------------------------------------------------

Oriented to events architeture:

This architeture rely of productors and clients of events where the main goal is 
split each module of the system and this are called when necessary. 

----------------------------------------------------------------------------------

Microservices architeure:

This architerure rely of modules of micro services small and independents wich ea-
ch servie solve a porblem and these modules conect yourselves trought a definited 
API.

ERP System arquiteture:

Database > Business rules > Process > Buy - Suplly Chain - Logistic - CRM

--------------------------------SOFTWARE TEST-------------------------------------

A sofware always containt defaults, what a test do is found current falls. Exists 
two types of concepts tests:

Validation: Is used to indetify if the software developed is the software that the 
client really want.

Verification: Verify if the functionalities of the software atend the software re-
quirements. Here, the performance, assecibility, accurancy, connection, values, 
platform compatibility and more requirements are tested.

----------------------------------------------------------------------------------

Stages of tests:

Development tests: The tests run while the development persist.

Release tests: Are the test that are done before the client.

User tests: The user usage is monitored.

----------------------------------------------------------------------------------

Types of tests:

Manual: Is used trought the development to test short functionalities.

Automatized: Programed tests that function a specific value corespondence.

Unity tests: Tests that are done in a single component/class or isolated part of 
the software.

Integration tests: Tests that are done in a set of components.

System test: The system is tested like one.

----------------------------------------------------------------------------------

Tests techiniques:

Test of black box: Only the requirements of the software are tested withou code 
code Verification.

Test of white box: Only the code is tested without validate the requirements.

TDD - Test Driven Development: Is the thechinic of run test before to implement 
the desired functionalitie. It not avoid the necessecitie of run tests on the 
system late.

-------------------------------SOFTWARE REUSE------------------------------------

Advantges:

Fast development, work loans reduce and conforrmity standard.

Penalty:

Without source code, without support.

---------------------------------------------------------------------------------

Techinique to reuse softwares

Maintain all your nucleo code in a generic isolated project of the type of sof-
ware of your client and show to your client what is obligatoly, alternative and 
optional functionalities.

---------------------------------------------------------------------------------

Development to reuse:

Is a generic and isolated sofware that is build to provide your components to 
another softwares.

Development with reuse:

Is the inhrerting of already existing components of a generic software.

---------------------------------------------------------------------------------

Rules to provide components:

The components need be standarted, with a good interface and documentation with 
use orientations.

The components need be indenpendents.

The component should can be used with another components, passive to componenti-
zation.

---------------------------------------------------------------------------------

Rules to consume components:

Sketch your system requirements before to use third components.

Identify the components that can be used in your system before to project your 
architure. If necessary, modifies the component by according your needs.


--------------------------------GENERAL TIPS--------------------------------------

Changes of requirements are unavoidable in big projects.

You can to combine various development methods in a single project.

Handler your software chnages trought the Software Changes Manager.

Each new version should be tested before to preced with new version development.

The minimum quanitty of tests should to get the maximum of failures.

