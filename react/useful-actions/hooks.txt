==================================HOOKS==================================

Is a spcecial function that allow to uses react features of the
state to a function component.

--------------------------------useState()-------------------------------

Is used to use and change the state of the function component.
This always is setted in a const receiving a array. The initial
values is passed how parammeter and the change of state is setted
by the second item of the array. Example:

const [number, setNumber] = useState(5)
changeNumber = () => {
setNumber(3)
}

------------------------------useEffect()-------------------------------

This features should be used when is necessary to uses functions
that treat with intervals and relation with the life cicle of the
function component. The useEffect is executed only one time, when the
application is started. When the second parammeter of the useEffect is 
empty, it means that the function will be run only one time. Example:

import React from 'react'
import {useState, useEffect} from 'react'
import {View, Text, StyleSheet, TouchableOpacity} from 'react-native'

export default function UseStateExample(){

  const [count, setCount] = useState (0)
  const [msg, setMsg] = useState ('')

  useEffect(()=> {
    setMsg('Changed ' + count + ' times.' )
  },[count])

  function increaseCount(){
    setCount(count + 1)
  }

  return(
    <View style={styles.container}>
      <Text>Use State Example:</Text>
      <TouchableOpacity onPress={increaseCount}>
        <Text>Click-me</Text>
      </TouchableOpacity>
  <Text>{count}</Text>
    </View>
  )
}

//useEffect with timer:

import React from 'react'
import {useState, useEffect} from 'react'
import {View, Text, StyleSheet, TouchableOpacity} from 'react-native'

export default function useEffectExamples () {

  const [count, setCount] = useState(0)

  useEffect( () => {
    const interval = setInterval( () => {setCount(count + 1)}, 1000)
    return ()=> {
      clearInterval(interval)
  }  
  })

  return(
    <View style={styles.container}>
        <Text>Count: {count}</Text>
    </View>
  )
}

-----------------------------useCallback()-----------------------------

Is used to memorize functions, to avoid render unnecessary func-
tions. When a function is renderized for first time, don't need
be renderizend again if is inside a useCallback hook. This hook
leaves two arguments: the function and an dependencies array. 

Example:

import {useState, useCallback} from 'react'
import React from 'react'
import { View, Text, Button, StyleSheet } from 'react-native'

const App = () => {

  const store = new Set()
  const [count1, setCount1] = useState(0)
  const [count2, setCount2] = useState(0)

  const increment1 = useCallback(()=> setCount1
	(count1 => count1 + 1), [count1])
  const increment2 = useCallback(()=> setCount2
	(count2 => count2 + 1), [count2])

  store.add(increment1)
  store.add(increment2)

  return (
    <View style={styles.container}>
      <Text>useCallBack example</Text>
      <Button title='Count1' onPress={increment1}></Button>
      <Button title='Count2' onPress={increment2}></Button>
      <Text>Count1: {count1}</Text>
      <Text>Count2: {count2}</Text>
      <Text>Store: {store.size -2}</Text>
    </View>
  )
}

------------------------------useMemo()--------------------------------

Executes a function only when your value changes. Example:

import React from 'react'
import {useState, useMemo} from 'react'
import { View, Text, Button, TextInput, Alert } from 'react-native'

export default function App () {

  const [total, setTotal] = useState(0)
  const [x, setX] = useState(0)
  const [y, setY] = useState(0)
  
  //ONLY DISPLAY ALERT IF THE RESULT OF THE SUM CHANGES
  //IF DOESN'T USING useMemo, ITS DISPLAY THE RESULT EVERY TIME
  const sumValues = (x, y) => {
    Alert.alert('My title', 'ok')
    return x + y
  }

  const result = useMemo(() => sumValues(x,y), [x,y])

  return(
    <View>
      <Text>useMemo example</Text>
      <TextInput
      keyboardType='numeric'
      onChangeText={(valueX) => valueX.length ? setX(parseInt(valueX)) 
	: setX(0)}
      value={x.toString(10)}
      textAlign='center'
      />
      <TextInput
      keyboardType='numeric'
      onChangeText={(valueY) => valueY.length ? setY(parseInt(valueY)) 
	: setY(0)}
      value={y.toString(10)}
      textAlign='center'
      />
    <Text>Result: {total}</Text>
      <Button title='Count2' onPress={ () => setTotal(result)}></Button>
    </View>
  )
}

--------------------------------useRef()---------------------------------

Is used to store a ref and use it later without need render
again.

import React from 'react'
import {View, Text, Button, TextInput} from 'react-native'
import {useRef} from 'react'

export default function App(){

  const refInput = useRef(null)

  const getFocusInput = () => {
    refInput.current.focus();
  }

  return(
  <View>
    <Text>useRef example:</Text>
    <TextInput
    textAlign='center'
    ref={refInput}
    />
    <Button
    title='Get form focus'
    onPress={() => {getFocusInput()}}
    />
  </View>
)
}

//GETING PREVIOUS STATE

import React from 'react'
import {View, Text, Button, TextInput} from 'react-native'
import {useRef, useState, useEffect} from 'react'

function getPreviousState(value){
  const ref = useRef()
  useEffect(() => {
    ref.current = value
  })
  return ref.current
}

export default function App(){

  const [count, setCount] = useState(0)
  const previousState = getPreviousState(count)

  return(
  <View>
    <Text>useRef example:</Text>
    <Text>Previous state:{previousState} Current state:{count}</Text>
    <Button
    title='Increment'
    onPress={() => {setCount(count + 1)}}
    />
  </View>
)
}

----------------------------useContext()----------------------------------

1) Initialize the context, create a functional component to provider your 
values (can be props or a state) and a custom to hook to use it.


import React, {createContext, useContext, useState} from 'react'

export const CounterContext = createContext()


export default function CountProvider({children}) {

    const[count, setCount] = useState(123424)

    return (
      <CounterContext.Provider value={{count, setCount}}>
          {children}
      </CounterContext.Provider>
    )
}


export function useCounter(){
    const context = useContext(CounterContext)
    const {count, setCount} = context
    return {count, setCount}
}

---------------------------------------------------------------------------

2) Destrucutrue the props of the hook and use in a component

import React from 'react'

import {useCounter} from './context/Countprovider'

export default function Counter() {

    const {count, setCount} = useCounter()

    return (
        <div>
           <p>Count: {count}</p> 
           <button onClick={() => {setCount(count + 1)}}>
	    Increase count
          </button>
        </div>
    )
}

----------------------------------------------------------------------------

3) Import the context provider to provider the context for your application 
and use the component with the context in your application.

import React from 'react'

import Counter from './Counter'
import CounterProvider from './context/Countprovider'

export default function App() {
  return (

    <CounterProvider>
        <Counter/>
    </CounterProvider>

  )
}


=============================GENERAL TIPS===================================

You can't to use the context directly in your App.js, you need to create a 
component to use it.
