===========================API INTEGRATION=============================

API  means, Application Programming Interface, and it is a set of 
specifications of possible interactions between applications. 

An API integration is the communication between your app and the a-
vailables resources of  third API's. The main types of API's are:

Collections API.
Payment API.
API for calc shipping and another calcs.
Authentication API.
communication API (send email and messages - sms).

At creating an API you should to document what are the available 
end-points and resources of your API. At consuming an API you should 
to check what are the available end-points and resources of the API.

----------------------------REST API's---------------------------------

REST is an architeture model and means Representation State Transfer 
and it has 6 basic rules:

1) Client and server must have different responsibilities.
2) The API needs to be Stateless, the server doesn't stores requests, 
all information should be provided in each request.
3) The API needs to have cache support.
4) The interface must be uniform with resources identification (ex: 
http://myapiendpoint/my_resource), resources representation (ex: JSON 
format), auto-descriptive messages, clear response messages and allow 
to return links in the JSON body.
5) The API must be created on layers, (load balance layers and others).
6) The response should be provided according to request demand.

---------------------------HTTP methods--------------------------------

GET: This is used to get data from the back-end.

POST: Creates a new data in the back-end.

PUT: Updates one or more data in the back-end.

PATCH: Updates a single data in the back-end.

DELETE: Removes a data in the back-end.

Examples:
POST: http://localhost:3333/users => Create a new user.
GET: http://localhost:3333/users => List users.
GET: http://localhost:3333/users/7 => List the user with ID = 7.

---------------------REQUEST RESPONSE PATTERN-------------------------

The request and response pattern works with the client doing the re-
quests for the server and so the server provide a response that can 
be different status code for the browser.


Main response status code:

Informational responses: (100–199)
Successful responses: (200–299)
Redirects: (300–399)
Client errors: (400–499)
Server errors: (500–599)

200: The request has succeeded and the method was called.

201: Request is OK and the new resource has been created.

202: The request has been received but not yet replied.

203: The returned data don't is exactly the same in the ori-
ginal server. It can collected from third-party.

204: There is no content to send for this request, but the 
headers may be useful. 

205: Tells the user-agent to reset the document which sent 
this request.

400: The server could not understand the request due to 
invalid syntax.

401: Unauthorized the client must authenticate itself to get 
the requested response.

403: Forbidden. The client does not have access rights to 
the content.

404: The server can not find the requested resource. In the 
browser, this means the URL is not recognized. In an API, 
this can also mean that the endpoint is valid but the resour-
ce itself does not exist.

405: The request method is not supported by the target resour-
se. For example, an API may forbid DELETE-ing a resource.

407: An authentication is needed to be done by a proxy.

409: A request conflicts with the current server state.

413: Request resources is larger than limits defined by the 
server.

414: The URI requested by the client is longer than the ser-
ver is willing to interpret.

415: The media format of the requested data is not supported
by the server, so the server is rejecting the request.

419: The user has sent too many requests in a given amount 
of time ("rate limiting").


451: The user-agent requested a resource that cannot legally 
be provided, such as a web page censored by a government.

500: Has some trouble with the server or connection error.

503: The server is not ready to handle the request. Common 
causes are a server that is down for maintenance or that is 
overloaded.

504: The server can't process the response in time.

505: The HTTP version used in the request is not supported 
by the server.

511: The client needs to authenticate to gain network access.

----------------------Parameters types----------------------------

Header params: Are params embed in the header of the request.

Example: 
authority: pablosilvadev.com.br
method: GET
path: api/getusers
scheme: https

----------------------------------------------------------------

Request params: Params that arrives in the route by itself that 
identifies fundamental resources. The parameter used to identify 
resources must be the same of the request.params.

Example:

app.get('/users/:id', (req, res) => {
	const getUser = request.params.id
})


----------------------------------------------------------------

Query Params: 

Params that query optionals resources, are useful to filter data 
and do pagination. Examples:

Code: { period } = req.query
URL: http://localhost:3333/orders/?period=90


---------

Code: { period, isActive } = req.query 
URL: http://localhost:3333/orders/?period=90&isActive=true

----------------------------------------------------------------

Request Body: 

Is the body of the requisition, params to create 
and update data. The object created must be in JSON format.

----------------------------------------------------------------

Route Params: 

Used to identify unique resources, for example:
in code: app.get('/users/:id')
in URL:/users/1

-------------------------MIDDLEWARES-----------------------------

A middleware is a function that receives three params (req, res,
next) that comes between the request and the response params in a 
HTTP method and is used to standardize data that comes in the he-
ader defining if this HTTP method could to continue be executed.

Creating a middleware:

function verifyAccountCPFExists(req, res, next) {
    const { cpf } = req.headers

    const customer = customers.find(customer => customer.cpf === cpf)
    if (!customer) {
        return res.status(201).json({ error: "Customer not found" })
    }

	req.customer = customer

    return next()
}

--------

Using a middleware:

app.get('/statement', verifyAccountCPFExists, (req, res) => {

	const {customer} = req

    return res.json(customer.statement)
})

or

app.use(verifyAccountCPFExists)


========================GENERAL TIPS=============================

Use the correct HTTP method to do your request.

Use the most adaptive status code according your response.

Always extract the data of a response to use it in your appli-
cation keeping on mind that a response is composed by a header 
and a body and the data is always on body of the request.


