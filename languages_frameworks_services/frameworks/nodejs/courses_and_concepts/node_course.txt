==================================NODE COURSE===================================

Node is an open source platform that allow execution of the JavaScript on the 
Server side. It was built using V8 + LIBUV and other modules. The Node is sin-
gle thread, but this unique thread is the event loop that is responsible for 
listen to and redistribute the functions inside the call stack to be executed 
on another 4 threads, that allow that the functions can be executed asynchro-
nously.Node has with native modules, like Https, FS, Dns, Buffer and others.


-------------------CUSTOMING ERRORS ON NODEJS APPLICATIONS----------------------

1) Install the express-async-errors running yarn add express-async-errors.

--------------------

2) Inside the src folder, create a new folder named as errors and inside this, 
create a file named as AppError and inside this export a class named as AppError 
passing a message and a statusCode as properties. Example:

export class AppError{
    public readonly message: string
    public readonly statusCode: number;

    constructor(message: string, statusCode = 400){
        this.message = message;
        this.statusCode = statusCode;
    }
}


--------------------

3) In your application uses the AppError class to deal with errors. Example:

if (userAlreadyExists) {
    throw new AppError('User already exists', 401);
}

--------------------

4) In the server.ts file import the express-async-errors and before app.listen,
define a custom middleare to deal with all errors on your application. Example:

import express, { json, NextFunction } from 'express';
import 'express-async-errors'

import { AppError } from "./errors/AppError";

const app = express();

app.use(json())

app.use((
    err: Error,
    req: express.Request,
    res: express.Response,
    next: NextFunction
) => {

    if (err instanceof AppError) {
        return res.status(err.statusCode).json({
            message: err.message
        })
    }

    return res.status(500).json({
        status: 500,
        message: `Internal server error: ${err.message}`
    })

})

app.listen('3333', () => {
    console.log('listening on 3333');
})

---------------------------------STREAM----------------------------------------

Stream is the technic of handling big files and process small pieces of 
theses files (chunks) and use these chunks according the application needs 
before the entire file is available. Th server can read and work with the 
received data according it goes coming.

To know the concept of Stream is important to understand how improve the 
server performance and deal with heavy requests(like a large file upload, a 
video reading and so on).

Type of streams:

Readable stream: Are streams where the back-end receive data in small pieces 
from the front-end. Ex: Front-end is uploading a file to the server or 
reading a file from the database.

Writable stream: Are streams where the back-end sent the data in small pieces 
to the front-end. Ex: Streams platform like Twitch server chunks of a video 
that are loading by the browser or doing an insertion into a database.

Transformable stream: Are streams that obligatory receive data a readable 
stream, use the method _transform to work with this data, and back this data 
to a writeable stream.

Buffer is a model to transfer data on NodeJs. It's a hexadecimal temporary 
representation of a space in the computer memory. 

---------------------------

Using Streams

In this example there is a Readable that reads a Stream content if its length 
is lower than 100.  

import { Readable } from "node:stream";

class OneToHundredStream extends Readable {
  index = 1;
  //_read() method is required in a Readable class
  _read() {
    const i = this.index++;
    setTimeout(() => {
      if (i > 100) {
	//push here refers to Readable class
        this.push(null);
      } else {
	//Buffer only accepts strings
        const buff = Buffer.from(String(i));
	//Every chunk should be in Buffer format
        this.push(buff);
      }
    }, 100);
  }
}

// pipe(process.stdout) print on console each buffer read from our class.
new OneToHundredStream().pipe(process.stdout);

----------------------

In this example there is a Readable stream and Writeable stream where the 
writeable stream format the value of each buffer read from the class 
OneToHundredStream.


class OneToHundredStream extends Readable {
  index = 1;
  _read() {
    const i = this.index++;
    setTimeout(() => {
      if (i > 100) {
        this.push(null);
      } else {
        const buff = Buffer.from(String(i));
        this.push(buff);
      }
    }, 100);
  }
}

class MultiplyByTenStream extends Writable {
  _write(chunk, encoding, callback) {
    const calculatedChunk =  Number(chunk) * 10
    const formattedChunk = `Line ${calculatedChunk}`
    console.log(formattedChunk)
    callback()
  }
}


//pipe() do the communication between the Readable and Writable streams.
new OneToHundredStream().pipe(
  new MultiplyByTenStream()
);

----------------------


In this example there is a Transformable Stream transform a the buffer from a 
readable stream and backs it to the Writeable stream where the writeable stream 
format again the value of each buffer read from the class OneToHundredStream.

import { Readable, Transform, Writable } from "node:stream";

class OneToHundredStream extends Readable {
  index = 1;
  _read() {
    const i = this.index++;
    setTimeout(() => {
      if (i > 100) {
        this.push(null);
      } else {
        const buff = Buffer.from(String(i));
        this.push(buff);
      }
    }, 100);
  }
}

class InverseNumberStream extends Transform {
  _transform(chunk, encoding, callback) {
    const transformedChunk = Number(chunk.toString()) * -1;
    callback(null, Buffer.from(transformedChunk.toString()));
  }
}

class MultiplyByTenStream extends Writable {
  _write(chunk, encoding, callback) {
    const calculatedChunk = Number(chunk) * 10;
    const formattedChunk = `Line ${calculatedChunk}`;
    console.log(formattedChunk);
    callback();
  }
}

new OneToHundredStream()
  .pipe(new InverseNumberStream())
  .pipe(new MultiplyByTenStream());

----------------------------------------------------------------------------------

Using Stream on HTTP methods example:

In this example the InverseNumberStream class will process the data that is 
coming from req and will return it processed through response. For each number 1 
to 100 the server will read the request and return a calculated response whereas 
each chunk is received. This process is done at once.

Server file:

import http from "node:http";
import { Transform } from "node:stream";

class InverseNumberStream extends Transform {
  _transform(chunk, encoding, callback) {
    const transformedChunk = Number(chunk.toString()) * -1;
    console.log(transformedChunk);
    callback(null, Buffer.from(transformedChunk.toString()));
  }
}

const server = http.createServer((req, res) => {
  return req.pipe(new InverseNumberStream())
  .pipe(res);
});

server.listen(3336);


--------------------------------

Client file:

  import {Readable} from 'node:stream'

class OneToHundredStream extends Readable {
    index = 1;
    _read() {
      const i = this.index++;
      setTimeout(() => {
        if (i > 100) {
          this.push(null);
        } else {
          const buff = Buffer.from(String(i));
          this.push(buff);
        }
      }, 100);
    }
  }

  fetch ('http://localhost:3336', {
    method: 'POST',
    body: new OneToHundredStream(),
    duplex: 'half'
  })


-------------------------------------------------------------------------------

Using streams to process data only if all data request is received.

In this example the code will return fullStreamContent only after the entire 
data is received, in this cases, only after OneToHundredStream class finish 
executing its method.

Client file:

import { Readable } from "node:stream";

class OneToHundredStream extends Readable {
  index = 1;
  _read() {
    const i = this.index++;
    setTimeout(() => {
      if (i > 10) {
        this.push(null);
      } else {
        const buff = Buffer.from(String(i));
        this.push(buff);
      }
    }, 100);
  }
}

fetch("http://localhost:3336", {
  method: "POST",
  body: new OneToHundredStream(),
  duplex: "half",
})
  .then((res) => {
    return res.text();
  })
  .then((data) => {
    console.log(data);
  });

------------------------

Server file:

import http from "node:http";

const server = http.createServer(async (req, res) => {
    const buffers = []
    for await (const chunk of req){
        buffers.push(chunk)
    }
    const fullStreamContent = Buffer.concat(buffers).toString() 
    return res.end(fullStreamContent)
});

server.listen(3336);

-------------------------------------------------------------------------------

Stateless application: Doesn't save anything in memory. Use databases.

Stateful application: Use the computer memory to save data and refresh the 
memory value at server restarting. Use arrays to store data.

-------------------------------------------------------------------------------

At working with Nodejs, the server can not return a response as an array. The 
response must be a string or an object (like JSON).

-------------------------------------------------------------------------------

Set the header response as content type Application/json to your response 
return the data like a JSON structure. Ex:

http.createServer((req, res) => {
	const myData = queryResult
	return res.setheader('Content-type' , 'application/json')
	.end(JSON.stringify(myData)
})

-------------------------------------------------------------------------------

Everything a user type into a NodeJs terminal is a process.stdin that will be 
processed and returned as process.stdout.

-------------------------------------------------------------------------------

At working with Streams/Buffer on NodeJS a request/response can read/send a
 piece of data for each piece of data instead of await for all data in the 
 request/response be read/send. On NodeJS the params (req, res) of a http 
 are on the most cases readable/writable streams respectively.

-------------------------------------------------------------------------------

Some boolean databse fields can be exchanged for when that data is available.
Ex: Exchange is_validated: Boolean for validated_at: DateTime.



