
------------------------CREATING A NEW NEXT PROJECT--------------------------

1) Run the command yarn create next-app name-of-application.

2) Install the typescript and your depenecies:
yarn add typescript @types/react @types/react-dom @types/node -D

3)Rename the files _app.js and index.js to _app.tsx and index.tsx inside 
the folder pages.

4)If there is, remove the importation of globalstyles.css file and delete it.

5)Run yarn dev to start the application.

6)If you will to use Styled Components, run yarn add styled-components.

7)Install the Babel for Styled components runnig babel-plugin-styled-components 
and create a .babelrc in the root of the project with settings:

{
  "presets": ["next/babel"],
  "plugins": ["styled-components"]
}

8) Replace the content of the files _app and _document.js to the content of
the correspondent files on the repo https://github.com/vercel/next.js/tree/
canary/examples/with-styled-components. Rename the files app.js and index.js 
to .tsx and maintain _document.js.

----------------------------GENERATING STATIC SITES-------------------------------

1)After your site is finished, run  yarn next build to create the build of your pro-
ject. The next will generates a log for your build (here your need a server to see
your application).

2)In the package.json create a new command: "export" : "next export".

3)Run the new command npm run export to export your static page to a new folder na-
med "out" (here your don't need a server).

4)You can open your file locally.


-------------------GETTING DATA FROM STATIC PROPS WITH TYPESCRIPT----------------

The getStaticProps is used for get/provide data for pages that are indexed in the
pages folder. Example:

1)Create a getStaticProps function to get/provide the data for your component 
returnnig an object named "props":

export const getStaticProps : GetStaticProps = () => {
    return{
        props:{
            name: 'Pablo'
        }
    }

}


--------------------------

2)Consume it in your component:


import { GetStaticPaths, GetStaticProps } from "next";


type Naming = {
    name: string
}

export default function Home({name} : Naming){
    return(
        <p>Hello, {name}</p>
    )
}

-----------GETTING DATA FROM STATIC PROPS IN DYNAMIC FILES WITH TYPESCRIPT------------

The getStaticProps is used together with getStaticPaths for get/provide data for 
pages that aren't indexed in the pages folder. Slugs. In this case, the data will 
only available on "challenges" route. Example:


1)Create a getStaticProps function to get/provide the data for your page 
returnnig an object named "props":

export const getStaticProps : GetStaticProps = () => {
    return{
        props:{
            name: 'Pablo'
        }
    }

}

--------------------------

2)Create a getStaticPaths function to get/provide the data for your component 
returnnig an object named "props":

export const getStaticPaths : GetStaticPaths = () => {
    return{
        paths: [{
            params: {
                slug : 'challenges'
            }
        }],
        fallback: false
    }
}

--------------------------

3)Consume it in your component:

export default function Slug({name} : Naming){
    return(
        <p>Hello, {name}</p>
    )
}


-------GENERATING STATIC PAGES TROUGHT DYNAMIC FILES BASED ON API RESOURCES-------

In this example, static pages are available according the number of users that
there are on the API. Each page is provided accessing the user id trought the rou-
te endpoint.


1)Create a folder with the route name that you want to render dynamiclly with the
[end-point].tsx file that you will use to access the dynamic resource. Exmaple:
create a folder named users with a file [id].tsx.

2)Do the request inside the getStaticProps function and return the response for 
your component:

export async function getStaticProps(context) {

    const response = await axios.get('https://jsonplaceholder.typicode.com/users', {
        params: { id: context.params.id }
    })
    
    const user = await response.data[0]

    return {
        props: {
            user: user
        }
    }
}

3) Defines which api resource will allow acess to your routes returning the prop
as the end-point of a path. In this case was returned an array of paths where the
id is the end-point:

export async function getStaticPaths() {

    const response = await axios.get('https://jsonplaceholder.typicode.com/users')
    const users = await response.data

    const paths = users.map((user) => {
        return {params: {id: String(user.id)}}
    })

    return {
        paths,
        fallback: false

    }
}


---------------------------

4)Consume the prop exported from getStaticProps in your component:

export default function Users({ user }) {

    return (
        <div>
            <h1>Hello from users</h1>
            <h3>Current user: {user.id}</h3>
       
        </div>
    )
}

-------------------ACCESSING DYNAMIC ROUTES BASED ON CURRENT PROP------------------


1) Define the resource to provide:

export async function getStaticProps(){

    const response = await Axios.get('https://jsonplaceholder.typicode.com/users')
    const data = await response.data

    return{
        props:{
            data
        }
    }
}

-----------------------------

2) Do a map from the data received and access the route referent the user renderized 
(you should to have a folder with the name of the route end-point, in this case, a 
folder named users):

import Axios from "axios"
import Link from 'next/link'

export default function Users({data}){
return(
    <div>
        <h1>Hello from Users.</h1>
        {data.map(user => (
        <Link key={user.id} href='users/[id]' as={`/users/${user.id}`} passHref>
            <p>{user.name}</p>
        </Link>
        ))}
    </div>
    )
}


------------------------USING DYAMIC FUNCTION IMPORTER---------------------------

Use the dynamic function to do imports of packs that need to interact with the 
window. Example:

import dynamic from 'next/dynamic'

const Chart = dynamic(() => import('react-apexcharts'), {
    ssr: false
})


--------------------------------GENERAL TIPS-------------------------------------

Use trailingSlahs: true in next.config.json file for enables the next navigate 
between intern links after the page is build. This option creates a folder for 
each file and rename the current file to index turning the file readble for the 
server.

The next router system will try load files that math with the url, case negative 
it will lead slug files or finally show 404 page.

On NextJS, React components should be exported only with "export default function" 
format.

Use router.isFallback props from the useRouter hook to return and reder a loading 
component while isFallback is true. It should be used with fallback:true in 
getStaticPaths function.

When fallback is true, you can't export your pages. Only with fallback:true is 
possible to use the revalidate and access the prop isFallback from router from 
the useRouter() hook.


getStaticProps is a function to pass your backend props to front-end whereas 
getStaticPaths is a function to handle routes on dynamic files.

When you use dynamic routes, rename the name of the dynamic folder as same name
of another static page file if you want to share even props.

You can to use 4 types of environment variables: .env, .env.local, .env.produc-
tion and .env.development where the .env is the default. The .env is where the 
system will to search for values if don't find in the others .env files. Use 
different .env file according the stage of your project.

Don't import the css files inside the _doucment,tsx file. Import the global.scss
in app.tsx.

Use dynamic titles importing the head in each page of the application.

You can use next functions (getServerProsp, getStaticProps and etc...) in page
files. If a component need a prop from getServerProsp by example, it should be
receive from a parent page file.

The function getStaticProps should be used in static pages with universal con-
tent,  getServerSideProps in dynamic calls like if an user is logged. Client
side calls (useEffect for data fetching) should be used in actions that no ne-
eds indexation.

At working with React and Next, you can consume data from getServerSideProps,
getStaticProps and useEffect. You should to think and defines each call. A 
blog by example should has your post loaded from getStaticProps and each user
comments with useEffect.

The content and functionalities of back-end in NextJS works in serverless af-
ter the deploy (Vercel, Netlify, etc).

There are different types of authentication (NextAuth, JWT, OAuth and etc), 
you should define the authentication type according to your application. For
simples applications, you can use NextAuth.

Use JSON.stringify(your_data, null, 2) to turn cascade objects more redable,
(use in objects that containds nested arrays).

Always format your data from third API's before consuming it in your compo-
nent. Do it in Next functions (getServerSideProps or getStaticProps).


Avoid to use fallback:true because it not is the ideal for SEO. The fallback:
false returns 404 page if the page don't be generated at the moment and fall-
back:blocking does the same of the fallback:true, but does it in the back-end
and should be used for load future pages.

GetStaticPaths only can be used inside dinamic pages/files (pages/files with pa-
rametrization) [slug].tsx.

The Next mounts your HTML page through the Next server, and it doesn't' has ac-
cess to the window object, thus, this throws an error in the application 
'window is not defined'. You should repair this error using the dynamic function 
from the next.

Import the regenerator-runtime from runtime (import "regenerator-runtime/runtime")
inside the [...nextauth].ts file to improve your app performance score.


