# React Course

## Introduction

React is a **JavaScript library** for building **user interfaces (UI)**, created and maintained by Facebook (now Meta).  
It focuses on creating reusable UI components, making development **faster**, **more organized**, and **scalable**.

Instead of manipulating the browser's **DOM** (Document Object Model) directly, React uses a **Virtual DOM**, which is an in-memory representation of the real DOM.  
React calculates the difference (**diffing**) between the current UI and the updated UI, and then updates only the necessary parts (**reconciliation**), improving performance.

---

## Installation

1. Install **Node.js** on your computer ([Download here](https://nodejs.org/)).
2. Open a terminal in VS Code and run:
   ```bash
   npx create-react-app my-app
   cd my-app
   npm start
   ```
3. The development server will start and open your app at `http://localhost:3000`.

_(Note: React projects generated by `create-react-app` already include `index.html` and `index.js` inside the `public` and `src` folders, so you do not need to create them manually.)_

---

## Fundamental Concepts

### Components

- **Function Components:** The most common way to build UI in React using JavaScript functions.
- **Class Components:** Older way of creating components, still supported but less used.
- Components must **return JSX** (JavaScript XML), a syntax extension that allows mixing HTML-like code with JavaScript.

### JSX

- Looks like HTML but is **not** HTML.
- Must return **a single parent element**.
- Allows embedding JavaScript expressions inside `{ }`.

Example:

```javascript
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}
```

### Props (Properties)

- Read-only values passed from parent to child components.
- Allow reusability and customization of components.

### State

- Data managed inside a component using `useState` (for function components).
- Changing state triggers a **re-render**.

### Virtual DOM

- React keeps a lightweight copy of the real DOM.
- Updates only the changed parts, improving performance.

### Hooks

- Functions that let you use React features without writing a class.
- Common hooks: `useState`, `useEffect`, `useContext`, `useReducer`, `useRef`.

### Synthetic Events

React uses **SyntheticEvent**, a cross-browser wrapper around the browser’s native event system.  
This ensures event properties work the same across different browsers.

Example:

```tsx
function Button() {
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    console.log("Button clicked!", event);
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

Key Points:

- Synthetic events normalize event behavior.
- Event handlers receive a SyntheticEvent object.
- They are **pooled** for performance, so properties may be nullified asynchronously (use `event.persist()` to retain).

---

### Controlled Components

In **controlled components**, form input values are controlled by React state.  
The value displayed is always driven by `state`.

Example:

```tsx
import React, { useState } from "react";

export default function ControlledForm() {
  const [name, setName] = useState("");

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value);
  };

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    console.log("Submitted name:", name);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" value={name} onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

**Advantages:**

- Predictable data flow.
- Easier validation and formatting.

---

### Uncontrolled Components

In **uncontrolled components**, form values are handled by the DOM, and you use refs to access them.

Example:

```tsx
import React, { useRef } from "react";

export default function UncontrolledForm() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    console.log("Submitted name:", inputRef.current?.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" ref={inputRef} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

**Advantages:**

- Less code for simple forms.
- Closer to plain HTML form handling.

---

### Keys in Lists

When rendering lists in React, each item needs a **unique `key` prop** for efficient diffing.

Example:

```tsx
const items = ["Apple", "Banana", "Cherry"];
return (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{item}</li>
    ))}
  </ul>
);
```

---

### Conditional Rendering

React allows rendering components or elements conditionally using:

- **Ternary operators**
- **Logical AND (`&&`)**
- **Early returns**

Example:

```tsx
{
  isLoggedIn ? <Dashboard /> : <Login />;
}
{
  notifications.length > 0 && (
    <p>You have {notifications.length} notifications</p>
  );
}
```

---

### Stateless and stateful components

**Stateless components**
Components that has not a state. Example:

```typescript
const Greeting = ({ name }: { name: string }) => <h1>Hello, {name}!</h1>;
;
```

**Stateful components**
Components that has a state.

```typescript
const Counter = () => {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
};
```

### Fragments

Fragments allow grouping elements without adding extra DOM nodes.

Example:

```tsx
import React from "react";

function MyComponent() {
  return (
    <>
      <h1>Title</h1>
      <p>Paragraph</p>
    </>
  );
}
```

---

### Context API

The **Context API** allows passing data deeply without manually drilling props at every level.

---

### Error Boundaries

Error boundaries catch JavaScript errors anywhere in a component tree and prevent them from breaking the entire app.

---

### Portals

Portals allow rendering children into a DOM node outside of the parent component hierarchy. Portals are largely used on modals, tooltips, toast and similar libraries that needs to position/style components detached from the components that are root div.

Example:

```tsx
import ReactDOM from "react-dom";

function Modal({ children }: { children: React.ReactNode }) {
  return ReactDOM.createPortal(
    children,
    document.getElementById("modal-root")!
  );
}
```

---

## Side Effects

In React, **side effects** are operations that affect something outside the scope of the current function, such as:

- Fetching data from an API.
- Subscribing to a data stream.
- Directly manipulating the DOM.

Side effects are handled inside the `useEffect` hook.

Example:

```javascript
useEffect(() => {
  document.title = "React Course";
}, []);
```

---

### Memoization with React.memo

`React.memo` prevents unnecessary re-renders of a component if its props haven’t changed.

Example:

```tsx
const MyComponent = React.memo(function MyComponent({
  name,
}: {
  name: string;
}) {
  console.log("Rendered:", name);
  return <p>{name}</p>;
});
```

---

### useCallback and useMemo

- **`useCallback`**: Memoizes a function.
- **`useMemo`**: Memoizes a computed value.

Both help optimize performance in large applications.

---

## Lazy Initializer

A **lazy initializer** occurs when you pass a function to `useState` to compute the initial value **only once** (on mount).  
This is useful for expensive calculations.

Example:

```javascript
const [value, setValue] = useState(() => {
  return heavyComputation();
});
```

---

## MVC (Model-View-Controller)

**Traditional Web Apps (Server-Side Rendering)**:

- The browser sends a request to the server.
- The server returns a **full HTML page**.
- Each navigation triggers a **full reload**.

**Problems:**

- Slower navigation.
- Redundant data transfer.

---

## SPA (Single Page Applications)

- The browser loads **one HTML file**.
- All navigation and updates happen using **JavaScript**.
- Data is fetched from the server in **JSON** format.
- Pages update without **full reloads**, improving performance.

**Advantages:**

- Faster navigation.
- Better user experience.
- Separation of frontend and backend.

**Example Frameworks/Libraries for SPA:**

- React
- Vue.js
- Angular

## React Renderization Order

The render process in React happens in the following way:

1. React generates a **new version** of the component and stores it in memory.
2. React compares this new version with the **previous version** (Virtual DOM comparison).
3. Using the **reconciliation algorithm**, React updates only the parts of the DOM that have changed, minimizing re-renders.

React will **re-render** your components when:

- The **parent component** changes.
- A **prop** of the child component changes.
- The **state** (via hooks) changes.

---

## React Hooks Execution Order

1. **Run `useState()`** and initialize any lazy initializers.
2. **Render the component**.
3. **Update the DOM**.
4. Run **`useLayoutEffect()`** (if present) **before the browser paints**.
5. **Render the component** again if layout effects cause changes.
6. Run **`useEffect()`** hooks **in the order they are declared**.

## Props communication

### Example 1: Passing Data from Child to Parent using Callback Functions (TypeScript)

**Parent Component:**

```tsx
import React, { useState } from "react";
import Child from "./Child";

export default function Parent() {
  const [message, setMessage] = useState<string>("");

  // Callback function to receive data from the child
  const handleDataFromChild = (data: string) => {
    setMessage(data);
  };

  return (
    <div>
      <h1>Parent Component</h1>
      <p>Message from child: {message}</p>

      {/* Pass the callback as a prop */}
      <Child sendDataToParent={handleDataFromChild} />
    </div>
  );
}
```

**Child Component:**

```tsx
import React from "react";

interface ChildProps {
  sendDataToParent: (data: string) => void;
}

export default function Child({ sendDataToParent }: ChildProps) {
  const handleClick = () => {
    sendDataToParent("Hello from the Child!");
  };

  return (
    <div>
      <h2>Child Component</h2>
      <button onClick={handleClick}>Send Message to Parent</button>
    </div>
  );
}
```

---

### Example 2: Passing Data from Parent to Child (TypeScript)

**Parent Component:**

```tsx
import React from "react";
import Child from "./Child";

export default function Parent() {
  const username = "Pablo";

  return (
    <div>
      <h1>Parent Component</h1>
      {/* Pass username as a prop */}
      <Child name={username} />
    </div>
  );
}
```

**Child Component:**

```tsx
import React from "react";

interface ChildProps {
  name: string;
}

export default function Child({ name }: ChildProps) {
  return (
    <div>
      <h2>Child Component</h2>
      <p>Hello, {name}!</p>
    </div>
  );
}
```

## Improving Performance in React Apps

To improve React applications, you should to observer the renderization process with
your rules. The React will re-render your components when:

- The parent component changes.
- A prop of children or a children component changes.
- When a hook changes.

We can to improve our applications using diferent tools:

### Memo

Memo should be used when your component is a medium/big components, pure func-
tional components (components that don't depends of third API's values and dynamic
values) and components that has too many renderizations. Example:

```tsx
import { memo } from "react";

interface ProductItemProps {
  product: {
    id: number;
    price: number;
    title: string;
  };
}

export default function ProductItemComponent({ product }: ProductItemProps) {
  return (
    <div key={product.id}>
      {product.title} - <strong>{product.price}</strong>
    </div>
  );
}

export const ProductItem = memo(
  ProductItemComponent,
  (prevProps, nextProps) => {
    return Object.is(prevProps.product, nextProps.product);
  }
);
```

---

### useMemo()

The hook useMemo() should be used to avoid that a heavy function be called again without
a reference is changed or when a even value provided from a function is passed from the
parent component to the children component. Example:

```tsx
import { useMemo } from "react";

const calcPrices = useMemo(() => {
  return results.reduce((acc, item) => {
    return acc + item.price;
  }, 0);
}, [results]);
```

---

### useCallback()

```tsx
import { useCallback } from "react";
```

The hook useCallBack() is used to avoid the React rebuild a function every time
that the component struggles a changes and renderize.This hook guarantee that
the function permanece in the same memory alocation. It should be used in func-
tions that are passed to children through prop drilling and functions that
provide from contexts. Example:

```tsx
const handleLogin = useCallback(() => {
  login();
}, []);
```

---

### Data formatation should happens at data consuming creating a new object, example:

```tsx
import React, { FormEvent, useCallback, useState } from "react"
import { SearchResults } from "../components/SearchResults"

export default function Home() {

  const [search, setSearch] = useState('')
  const [results, setResults] = useState([])

    const response = await fetch(`http://localhost:3333/products?q=${search}`)
    const data = await response.json()

    const formatter = new Intl.NumberFormat('pr-BR', {
      style: 'currency',
      currency: 'BRL'
    })

    const calcPrices = data.reduce((acc, item) => {
          return acc + item.price
      }, 0)

    const product = data.map(product =>{
      return {
        id: product.id,
        title: product.title,
        price: product.price,
        priceFormatted: formatter.format(product.price)
      }
    })

    setResults(data: product)

  }

  return (
    <>
      <h1>Searches</h1>
      <form onSubmit={handleSearch}>
        <input
          type="text"
          placeholder="Search"
          value={search}
          onChange={e => setSearch(e.target.value)}
        />
        <button type="submit">Buscar</button>
      </form>
      <SearchResults results={results.data}/>
    </>
  )
}
```

---

### Code Spliting and Lazy/Dyanimc loads

Dynamic as a feature of the Next and can be used to substitue the React Lazy. In ap-
plications that not uses Next, w'll using Next.

**Doing Lazy loading with Next Dyanamic:**  
To use the dynamic from Next, you should import the component that you wanna display
at user interaction, import the props of this component, pass it as a return of the
dynamic method and return an html in the loading prop as second param of the dynamic
funcion. In your component you must do a conditional renderization to render a user
feedback doing a ref to your dynamic method. Example:

```tsx
import React, { memo, useState } from "react";
import dynamic from "next/dynamic";
import { AddproductToWishListProps } from "./AddProductToWishList";

const AddproductToWishList = dynamic<AddproductToWishListProps>(
  () => {
    return import("./AddProductToWishList");
  },
  {
    loading: () => <span>Carregando...</span>,
  }
);

interface ProductItemProps {
  product: {
    id: number;
    price: number;
    title: string;
    priceFormatted: string;
  };
  onAddToWishList: (id: number) => void;
}

export default function ProductItemComponent({
  product,
  onAddToWishList,
}: ProductItemProps) {
  const [isAddingToWishList, setIsAddingToWishList] = useState(false);

  return (
    <div key={product.id}>
      {product.title} - <strong>{product.priceFormatted}</strong>
      <button onClick={() => setIsAddingToWishList(true)}>
        Adcionar aos favoritos
      </button>
      {isAddingToWishList && (
        <AddproductToWishList
          onAddToWishList={() => onAddToWishList(product.id)}
          onRequestClose={() => {
            setIsAddingToWishList(false);
          }}
        />
      )}
    </div>
  );
}

export const ProductItem = memo(
  ProductItemComponent,
  (prevProps, nextProps) => {
    return Object.is(prevProps.product, nextProps.product);
  }
);
```

## General Tips

---

Use `event.target.valueAsDate` to render date input content.

---

The scope that is inside the main component is executed first than functions outside the component scope.

---

Always the first element of a `map` return should be the prop `key` to identify the list items.

---

In React, it is not possible to render two or more elements without a fragment or wrapper element like a `<div>` — otherwise you'll get the **adjacent JSX elements** error.

---

Children components can pass props to the parent only through a **callback function**.

---

Side effects happen when `setState` is called directly in the function scope. States must always be handled inside a function or hook.

---

Use the **Computed Property Name** technique to handle an object through a function.

```ts
function updateObjectProp<T>(obj: T, key: keyof T, value: any): T {
  return { ...obj, [key]: value };
}

const user = { name: "Pablo", age: 29 };
const updatedUser = updateObjectProp(user, "age", 30);
console.log(updatedUser); // { name: "Pablo", age: 30 }
```

---

Use `useRef` for controlling HTML inputs, dropdowns, media, and other elements that need to be imperatively handled.

---

To pass two or more functions to a single synthetic event, wrap them in an arrow function with `{}`.

---

Always use two or more types for provider context in your application — one for the children prop and another for the data.

---

Use `setState` typed with `React.Dispatch` and `React.SetStateAction` and provide it in contexts to update values.

---

Always remove event listeners in `useEffect`:

```ts
useEffect(() => {
  const onScroll = () => {};
  window.addEventListener('scroll', onScroll);
  return () => {
    window.removeEventListener('scroll', onScroll);
  };
}, []);
```

---

Give feedback to users during requests (e.g., disable buttons on submit, show loading animations).

---

Prevent multiple requests by disabling buttons while a promise is pending.

---

Use the option `devtool: 'eval-source-map'` inside `webpack.config.js` for better error stack traces in development.

---

If `useEffect` can't call an external async function, define it directly inside the hook.

---

The component will re-render if state or props change; even an empty state can trigger render.

---

Put `<link>` tags at the top level in `index.html` for better performance.

---

Follow a naming convention: use descriptive function names in contexts (e.g., `addProduct` in `CartContext.tsx`) and prefix them with `handle` in UI components (e.g., `handleAddProduct` in `Product.tsx`).

---

When updating array state, use the spread operator to preserve the original array:

```ts
setPosts([...returnedPosts]);
```

---

Only import a library if it is actually used to reduce the final bundle size.

---

Be careful with global variable scope — it can cause duplicated calculations.

---

Use arrow function syntax only for inline event handlers or immediate actions; for calling a function directly during render, use the `function` syntax.

---

State should be **immutable** — always create a new copy when updating:

```ts
setState(prev => ({ ...prev, count: prev.count + 1 }));
```

This preserves history and avoids side effects.

---

`setState` is asynchronous — prefer the callback form to ensure you work with the latest value:

```ts
setState(prev => prev + 1);
```

---

Use object destructuring when possible to simplify syntax.

---

If possible, use `Promise.all()` to resolve multiple promises concurrently.

---

`Array.map` does not mutate the array and won't trigger re-render unless the array is in state and replaced.

---

Do data fetching in `useEffect` on first render, but avoid heavy computations during initial load.



---

If have some library in your package.json with "^" it's means that the dependency is 
the most recent and can change with time. If you desire that the lib doesn't update, 
remove the "^" character. Ex: "some-cool-lib": "^0.4.2" => "some-cool-lib": "0.4.2".

---

Have and organize your constants for the entire app. Have constants for messages, numbers, 
data and colors. Have a modularized app.

---

Use the memo from React when you have pure components or components that re-render 
too many times or the component is too big.

---

You can access an input's value directly by passing the prop `name` to it.

Example:

```tsx
<input type="text" name="test" />

function handleInput(e: FormEvent) {
  const newValue = e.target.test.value;
  setValue([...values, newValue]);
}
```

---

React uses declarative programming to handle states whereas Vanilla JavaScript uses 
imperative programming.

Example declarative programming:

```tsx
function handleInputChange(e: FormEvent) {
  const inputCurrentValue = e.target.test.value;
  setInputValue(inputCurrentValue);
  setInputValue('');
}

<input
  type="text"
  value={inputValue}
  onChange={handleInputChange}
  name="test"
/>
```

Example imperative programming:

```js
const input = document.getElementById('test');
let myName = '';

function handleInput() {
  myName = input.value;
  console.log(myName);
}
```

---

Prefer to write a function in isolation and pass this function on your button or another 
component instead of calling the function directly in the component for performance 
and legibility reasons.

---

Always tell TypeScript which element is triggering an event.

Example (an input inside a form):

```tsx
function handleInputChange(e: FormEvent<HTMLInputElement>) {
  // your code
}

<form>
  <input onChange={handleInputChange} />
</form>
```

---

You can use a trick of passing a state to a component key to force a new render by 
changing the state linked to this key.

---

Whenever possible, isolate all logic in your code, for fetching data, etc. Use hooks 
for it. Ex: useFetch, useCopyToClipboard and others.

---

Check if it is really necessary to create a new state. Sometimes you can use variables 
to store a value.

---

When using the Fetch API to handle requests, you must ensure your application sends the 
method, headers and the body (in string format).

Example:

```tsx
async function handleSignUp({ name, email, password }: FormDataProps) {
  setLoading(true);
  try {
    await fetch('http://localhost:3333/users', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ name, email, password })
    })
    .then(res => res.json())
    .then(data => console.log(data));
  } catch (error) {
    console.log(error);
    setLoading(false);
  } finally {
    setLoading(false);
  }
}
```

---

Do not create Input components with a fixed ref. Create them using `forwardRef` to 
allow the ref to be manipulated according to the application's needs.

---

To use context functions or hooks in files that are not returning a React component 
(.tsx files) you need to create a function in your context/hook that returns another 
function to be used in this non-.tsx file.

---

The major difference between useLayoutEffect and useEffect is that useLayoutEffect 
will block the browser from painting until your code inside useLayoutEffect completes, 
while useEffect doesn't.


