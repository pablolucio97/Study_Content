======================GRAPHQL COURSE=========================

GraphQL is a api manager that return only desired data avoi-
ding the overfetching and underfecthing data.

In GraphQL every request are of type post and every request 
is on even endpoint (/graphql).

---------INITIALIZING A GRAPHQL PROJECT WITH MONGOOSE--------


1) Run yarn init -y to start a new project and install the pa-
kages @babel/core @babel/cli @babel/preset-env and @babel/node 
as development dependency.

-------------------------------------------------------------

2) In the project root create a new file called .babelrc with
the config:

{
    "presets" : ["@babel/preset-env"]
}

-------------------------------------------------------------

3) Install the nodemon as development dependency and setting
it on packge.json:

"scripts": {
"dev" : "npx nodemon --exec babel-node src/index.js -e js,gql"
 }

-------------------------------------------------------------

4) Install the Apollo Server and the GraphQL running yarn 
add apollo-server graphql.

-------------------------------------------------------------

5) Create the src folder with the index and startServer file.

-------------------------------------------------------------

6) Defines a function inside the startServer file for the 
server initialization:

import {ApolloServer} from 'apollo-server'

function startServer({typeDefs, resolvers}){
    const server = new ApolloServer({typeDefs, resolvers})
    server.listen().then(({url}) => 
    console.log(`Server running at ${url} ✔`))
}

export {startServer}
-------------------------------------------------------------

7) Create a folder named graphhql with a file named typeDefs
containing the types for queries and mutations. Example

const typeDefsQuery = `
    type Query {
        hello: String
    }
`

export {typeDefsQuery}

-------------------------------------------------------------

8)Inside the even graphql folder create other file named re-
solvers.js. Example:

const resolvers = {

}

export { resolvers }

-------------------------------------------------------------

9) Starts the server invoking the startServer function and 
passing typeDefs and resolvers as params. Example:

import {startServer} from './startServer'
import {resolvers} from '../graphql/resolvers'
import {typeDefs} from '../graphql/typeDefs'

startServer({typeDefs, resolvers})

-------------------------------------------------------------

10)Install the mongoose running yarn add mongoose, inside the
startServer file imports the mongoose and starts the mongoose 
passing the server url and an option objects. Example:

import {ApolloServer} from 'apollo-server'

import mongoose from 'mongoose'

function startServer({typeDefs, resolvers}){

    mongoose.connect('mongodb://localhost:27017/graphql',{
        useNewUrlParser: true,
        useUnifiedTopology: true
    })

    const server = new ApolloServer({typeDefs, resolvers})
    server.listen().then(({url}) => 
    console.log(`Server running at ${url} ✔`))
}

export {startServer}

-------------------------------------------------------------

11) Create the models of your application creating a new fol-
der named models and inside this a new file with your model 
strucuture. Example:

import mongoose from 'mongoose'

const Schema = mongoose.Schema({
    title: {
        type: String,
        required: true
    },
    content: {
        type: String,
        required: true
    },

    author: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },

})

const postModel = mongoose.model('Post', Schema)

export { postModel }

-------------------------------------------------------------

12) Inside the graphql folder create a new folder named ac-
cording your entity name and a new file named resolvers with 
resolvers for Query and Mutation. Example:

const resolvers = {
    Query:{

    },
    Mutation:{
        
    }
}

export { resolvers }

-------------------------------------------------------------

13) Inside of the even folder with your entity name creates 
a new file named schema.gql with the types and inputs for 
yours entities. Example:

type User{
    _id: ID!
    title: String!
    content: String!
    author: User!
}

input PostInput{
    title: String!
    content: String!
    author: ID!

type Query{
    users: [Post!]!
    user(id: ID!): Post!
}

type Mutation{
    createPost(data: PostInput): Post!
    updatePost(id: ID, data: PostInput): Post!
    deletePost(id: ID!): Boolean
}

-------------------------------------------------------------

14) Run yarn add merge-graphql-schemas to join your schemas 
and inside the folder typeDefs import mergeTypes and path 
to concact your types:

import {fileLoader, mergeTypes} from 'merge-graphql-schemas'
import path from 'path'

const typesArray = fileLoader(path.join(__dirname, 
    'modules', '**', '*.gql'))
    
const typeDefs = mergeTypes(typesArray)

export {typeDefs}

-------------------------------------------------------------

15) Repeat the step 14 for concat the resolvers:

import {fileLoader, mergeResolvers} from 'merge-graphql-schemas'
import path from 'path'

const typesArray = fileLoader(path.join(__dirname, 
    'modules', '**', 'resolvers.js'))
    
const resolvers = mergeResolvers(typesArray)

export {resolvers}

-------------------------------------------------------------

16)In the file resolver of your modules, import the model that
you will to create queries and mutations and define your re-
solvers. Example:

import {postModel} from '../../../models/Post'

const resolvers = {
    Query: {
        posts: () => postModel.find(),
        post: (_, { id }) => postModel.findById(id)
    },
    Mutation: {
        createPost: (_, { data }) => 
        postModel.create(data),
        
        updatePost: (_, { id, data }) => 
        postModel.findOneAndUpdate(id, data, { new: true }),
        
        deletePost: async (_, { id }) => 
        !!(await postModel.findOneAndDelete(id))
    }
}

export { resolvers }

-------------------------------------------------------------

17) Run your queries and mutations in GraphQL console in
http://localhost:4000


---------------INITIALIZING A GRAPHQL PROJECT----------------

1) Run yarn init -y to start a new project ad install the A-
pollo server and the GraphQL with the commads:
yarn add apollo-server graphql.

------------------------------------------------------------

2) Import the ApolloServer and the gql from 'apollo-server' 
and instance them with resolvers passing the type of your 
query inside typeDefs and the function to execute inside the 
resolvers. Example:

const typeDefs = gql`
    type Query{
    hello: String;
`

const resolvers = {
    Query: {
    hello: () => 'Hello world'
}


const server = new ApolloServer({typeDefs, resolvers});

------------------------------------------------------------

4) Listen the server passing the url prop as params. Example:

server.listen().then(({url}) => 
console.log(`Server running at ${url}`))

------------------------------------------------------------

5) Starts the server running the directory of your applica-
tion.Example: node src/index.js

------------------------------------------------------------

6) Run your querys on GrapqhQL playground accessing 
http://localhost:4000/

-------------------------CONCEPTS----------------------------

Schema: Are the set of all types created in a GraphQL pro-
ject.

-------------------------------------------------------------

Query: Works at the method get in REST API's and is used to 
get data.
-------------------------------------------------------------

Mutation: Is used for manager data, working as the another 
REST methods (post, delete, patch, put);
-------------------------------------------------------------

ScalarTypes: Are the primitives types, ex: String, Int, Boo-
lean, Float and ID.

TypeDef: Types a query.

-------------------------------------------------------------

Resolvers: Executes a function method of the typeDefs mapping
the objects in GraphQL.



creating a query on GraphQL:


--------------------DOING TYPES NESTING------------------------

To do type nesting you need to pass a type for a prop to ano-
ther type. Using a type as a prop for another type is useful to
allow deep queries. Example:

Passing a type as prop for another type:

 const typeDefs = gql`

    type User {
        _id: ID!
        name: String!
        email: String!
        active: Boolean!
    }

    type Post {
        id: ID!
        title: String
        content: String
        author: User!
    }
 `
 
 
 Doing a deep query:
 
 {
    posts{
        author{
        name
        email
        active
        }
    }
 }
 
 
 -------------CREATING AND USING QUERIES FUNCTIONS-------------
 
1)Defines the query type:
 
  type Query {
        getUserByEmail(email: String!) : User!
    }
    
---------------------------------------------------------------  
    
2) Define the database or array to find:
 
 const users = [
    { _id: 1, name: 'Pablo', email: 'pablo@gmail.com },
    { _id: 2, name: 'Camila', email: 'camila@gmail.com'},
    { _id: 3, name: 'Jhenny', email: 'catjhenny@gmail.com'}
]
 
---------------------------------------------------------------

3) Defining the function in rsolvers:

const resolvers = {
 Query: {
    getUserByEmail: (_, args) => {
        return users.find((user) => user.email === args.email)
        }
    }
}

---------------------------------------------------------------

4) Searching in the Apollo console:

query {
  getUserByEmail(email: "pablo@gmail.com") {
   name 
   active
  }
}

------------------CREATING MUTATION FOR POST-------------------


1)Defines the query type:
 
    type Mutation {
        createUser(name: String, email: String): User!
    }
    
---------------------------------------------------------------  

2) Defining the post function in rsolvers:

 Mutation: {
        createUser: (_, args) => {
            const newUser = {
                _id: String(Math.random()),
                name: args.name,
                email: args.email,
                active: true
            }

            users.push(newUser)
            return newUser
        }
    }
---------------------------------------------------------------

3) Running the mutation in the Apollo console:

mutation{
  createUser(
    name: "Ivone"
    email: "iv.satana@gmail.com"
  ){
    name
    email
  }
}
 
=========================GENERAL TIPS==========================

At working with GraphQL not is necessary to use PostMan or In-
somnia to test api methods.

---------------------------------------------------------------

Don't use the type null at workng with GraphQL.

---------------------------------------------------------------

Always defined the id of each entity assingment it with the ID 
native of the GraphQL.

---------------------------------------------------------------

Use inputs for typing the params in mutations methods. Example:

input UserInput{
    firstName: String!
    age: Int!
    email: String
    active: Boolean
}


type Mutation{
    createUser(data: UserInput): User!
    updateUser(id: ID, data: UserInput): User!
}

---------------------------------------------------------------


3)B,GET, POST, PUT, PATCH, DELETE.
4)C
5)B
6)D
7)A
8)B
9)D
10)B
11)A
12)c
